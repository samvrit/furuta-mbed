// Included Files
#include <cpu_cla_shared.h>


// Defines

#define CURRENT_SCALING (0.003052503053f)   // [A/adc_resolution] = (3/4095)*(5/3)*(1/0.4)
#define CURRENT_BIAS_LPF_A (2.5e-6f)    // 4s time constant at 100kHz
#define TORQUE_CONSTANT (0.968f)    // [Nm/A]

#define CURRENT_CONTROLLER_KP (46.576f)       // [V/A]
#define CURRENT_CONTROLLER_KI (23.52902968f)  // [V/A] this term is already multiplied by the timestep (1e-5)
#define CURRENT_CONTROLLER_I_TERM_MAX (20.0f) // [V/A]

#define V_BRIDGE_MAX (12.0f)    // [V] DC voltage
#define PWM_PERIOD_COUNTER (2000.0f)    // same as defined in epwm_init.c

#define MAX(a, b) __mmaxf32((a), (b))
#define MIN(a, b) __mminf32((a), (b))

#define SAT(x, max, min) (MAX(MIN((x), (max)), (min)))

// Globals
float pi_control_i_term;
float current_bias;

__interrupt void motor_torque_control(void)
{
    const int32_t adc_raw = AdcaResultRegs.ADCPPB1RESULT.all;   // post processing block already has the offset subtracted
    const float current_val_raw = adc_raw * CURRENT_SCALING;

    // Accumulate bias when current controller is not active
    if (!cla_inputs.enable)
    {
        current_bias += (current_val_raw - current_bias) * CURRENT_BIAS_LPF_A;
    }

    const float current_ref = cla_inputs.torque_cmd / TORQUE_CONSTANT;

    const float current_feedback = current_val_raw - current_bias;

    const float error = current_ref - current_feedback;

    const float pi_control_p_term = error * CURRENT_CONTROLLER_KP;

    pi_control_i_term += error * CURRENT_CONTROLLER_KI;
    pi_control_i_term = SAT(pi_control_i_term, CURRENT_CONTROLLER_I_TERM_MAX, -CURRENT_CONTROLLER_I_TERM_MAX);
    pi_control_i_term = cla_inputs.enable ? pi_control_i_term : 0.0f;

    const float v_bridge = SAT((pi_control_p_term + pi_control_i_term), V_BRIDGE_MAX, -V_BRIDGE_MAX);

    const float duty_percent = v_bridge / V_BRIDGE_MAX;

    float counter_compare = PWM_PERIOD_COUNTER - (fabsf(duty_percent) * PWM_PERIOD_COUNTER);
    counter_compare = cla_inputs.enable ? counter_compare : PWM_PERIOD_COUNTER;

    const uint16_t direction = (duty_percent > 0.0f) ? 1U : 0U;

    EPwm1Regs.CMPA.bit.CMPA = __mf32toui16r(counter_compare);
    GpioDataRegs.GPADAT.bit.GPIO1 = direction;

    cla_outputs.current_feedback = current_feedback;
}


__interrupt void sw_task(void)
{
    // initialize global variables
    pi_control_i_term = 0.0f;
    current_bias = 0.0f;
}
