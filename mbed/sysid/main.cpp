/*=======================INCLUDES========================*/
#include "mbed.h"
#include "PwmIn.h"

/*=======================DEFINES========================*/
#define PI 3.14F
#define ROTATION_PER_PULSE (2.0F * PI / 16.0F)  // radians per pulse
#define GEARBOX_RATIO 30.0F

#define ABS(input) ((input) = (input) < 0 ? -(input) : (input))

/*=======================PERIPHERALS========================*/
DigitalOut motorEnable(PA_8);              // 3.3V power source for gate driver IC
PwmOut motorPWM(PA_5);                     // PWM for gate driver IC
PwmIn encoder(PB_6);                        // encoder input
DigitalOut inA(PA_6);                       // direction pin A
DigitalOut inB(PA_7);                       // direction pin B
AnalogIn backEmf(PB_0);                     // measure back emf generated by motor

InterruptIn buttonPress(BUTTON1);                // button for motor enable/disable

Timer t;

RawSerial dutyCycleInput(PA_0, PA_1);         // serial communication for getting duty cycle commands

/*=======================STRUCTS & UNIONS========================*/
typedef struct {
    bool motorEnabled = false;                  // flag for when motor is enabled using button
    bool dutyCycleCommandAvailable = false;     // flag for when new duty cycle command is available
} flags_t;

// use a union to decode float packet received through UART
typedef union {
    float value;
    char buffer[sizeof(float)];
} uartPacket_t;

/*=======================VOLATILES========================*/
volatile char rx_buffer[sizeof(float) + 1]; // receive buffer for UART packet containing duty cycle command
volatile int rx_count;                      // index for receive buffer byte array
volatile flags_t flags;
volatile uartPacket_t uartPacket;

/*=======================INTERRUPT HANDLERS========================*/
// Interrupt service routine for when user button is pressed for enabling/disabling motor driver
void flip(void)
{
    motorEnable = !motorEnable;   // 3.3V power source for gate driver IC
    flags.motorEnabled = !flags.motorEnabled;
}

// Interrupt service routine for UART RX
void rx_irq(void)
{
    while(dutyCycleInput.readable())
    {
        rx_buffer[rx_count] = dutyCycleInput.getc();  // fill available byte into buffer
        if(rx_buffer[rx_count] == '\r')             // look for carriage return
        {
            flags.dutyCycleCommandAvailable = true;
            rx_count = 0;                           // reset buffer index
            break;
        }
        else
        {
            rx_count++;                             // increment index counter
        }
    }
}

/*=======================MAIN========================*/
int main()
{
    dutyCycleInput.baud(115200);                          // set UART baud rate
    dutyCycleInput.attach(&rx_irq, RawSerial::RxIrq);

    dutyCycleInput.printf("Hello World!\r\n");

    buttonPress.rise(&flip);

    inA = 1;
    inB = 0;

    float dutyCycle = 0.0;
    float motorSpeed = 0.0;
    float dt = 0.0;
    float backEmfV = 0.0;
    float backEmfConstant = 0.0;

    motorPWM.period_us(100.0); // set PWM frequency to 100 microseconds (10 kHz)

    while(true)
    {
        if(flags.dutyCycleCommandAvailable)
        {
            NVIC_DisableIRQ(UART4_IRQn);    // disable UART interrupt while processing new information
            dutyCycleInput.printf("Torque command available! %02X %02X %02X %02X \n", rx_buffer[0], rx_buffer[1], rx_buffer[2], rx_buffer[3]);
            memcpy((void *)&uartPacket.buffer, (void *)&rx_buffer, sizeof(float));  // write buffer contents into union variable
            memset((void *)&rx_buffer, 0, sizeof(float) + 1);   // clear rx buffer
            dutyCycleInput.printf("New torque command: %f\n", uartPacket.value);
            dutyCycle = uartPacket.value;
            flags.dutyCycleCommandAvailable = false;

            inA = dutyCycle < 0 ? 0 : 1;    // set direction
            inB = !inA;
            NVIC_EnableIRQ(UART4_IRQn);     // enable UART interrupt after processing new torque command
        }

        motorPWM.write(ABS(dutyCycle));    // set duty cycle

        // obtain speed of motor
        dt = encoder.period();
        motorSpeed = ROTATION_PER_PULSE / dt;   // radians per second
        motorSpeed /= GEARBOX_RATIO;

        if(flags.motorEnabled)
        {
            backEmfV = backEmf.read() * 3.3;
            backEmfConstant = backEmfV / motorSpeed;
            printf("%f,%f,%f\r\n", motorSpeed, backEmfV, backEmfConstant);
        }  
    }

    return 0;
}